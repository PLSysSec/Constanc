embed
{{ tex-preamble
\usepackage{stmaryrd}
}}

metavar x ::= {{ com term variable }}
metavar f ::= {{ com function declaration? }}
metavar cnt ::= {{ com program counter }}
indexvar n ::= {{ com index variable }}
indexvar k ::= {{ com index variable }}

grammar
v :: 'v_' ::= {{ com values }}
  | c :: :: const  {{ com constant }}

e :: 'e_' ::= {{ com expressions }}
  | x :: :: var {{ com variable }}
  | c :: :: const  {{ com constant }}
  | unop e :: :: unop {{ com unary operation }}
  | e1 binop e2 :: :: binop {{ com binary operation }}
  | f ( e1 , .. , en ) :: :: funcapp {{ com function application }}

s :: 's_' ::= {{ com statements }}
  | skip :: :: skip {{ com skip }}
  | s1 ; s2 :: :: seq {{ com sequence }}
  | def x := e :: :: vardec {{ com variable declaration }}
  | x := e :: :: assign {{ com variable assignment }}
  | for x from v1 to v2 : s :: :: loop {{ com for loop }}
  | return e :: :: ret {{ com return statement }}

fdef :: 'fdef_' ::= {{ com function definitions }}
  | fdef f ( x1 , .. , xn ) : s :: :: fdef

program :: 'program_' ::= {{ com program }}
  | fdef1 ; .. ; fdefn ; expose fdef :: :: fdefs {{ com list of fdefs }}

fm :: fm_ ::= {{ com function store }}
  | fm_empty ::  :: efm {{ tex \emptyset_{fm} }} {{ com empty function store }}
  | fm , f ( v1 , .. , vk ) = s ; return e ::  :: vfm {{ com define function }}

m :: m_ ::= {{ com memory }}
  | m_empty ::  :: em {{ tex \emptyset_m }} {{ com empty memory }}
  | m , x := v ::  :: vm {{ com add/update variable }} {{ tex [[m]][ [[x]]:=[[v]] ] }}
  | m / x ::  :: rm {{ com remove variable }}

terminals :: 'terminals_' ::=
  | unop :: :: core_unop {{ tex \sim\!\!\! }}
  | binop :: :: core_binop {{ tex \oplus }}
  | --> :: :: core_reduce {{ tex \longrightarrow }}
  | in :: :: in {{ tex \in }}
  | [[ :: :: lbrack {{ tex \llbracket }}
  | ]] :: :: rbrack {{ tex \rrbracket }}
  | === :: :: equiv {{ tex \equiv }}

formula :: 'formula_' ::=
  | judgement ::  :: judgement
  | not ( formula ) ::  :: not {{ tex \neg ([[formula]]) }}
  | v' === [[ unop v ]] ::  :: eqv_unop
  | v3 === [[ v1 binop v2 ]] ::  :: eqv_binop
  | cnt' = succ cnt ::  :: succ {{ tex [[cnt']] = [[cnt]] + 1 }}
  | fm' = fm ::  :: eqv_fm
  | m' = m ::  :: eqv_m
  | v = v' ::  :: eqv_v
  | v < v' ::  :: ltv
  | v' = succ v ::  :: succ_v {{ tex [[v']] = [[v]] + 1 }}

subrules
  v <:: e

defns
  Jop :: '' ::=

    defn
    fm m cnt e --> fm' m' cnt' e' ::  :: expr_reduce :: Exr_ {{ com [[e]] reduces to [[e']] }}
    {{ tex \{[[fm]],[[m]],[[cnt]]\} [[e]] [[-->]] \{[[fm']],[[m']],[[cnt']]\} [[e']] }} by

    m = m' , x := v
    cnt' = succ cnt
    ---------------------------- :: var
    fm m cnt x --> fm m cnt' v

    fm m cnt e --> fm m cnt' e'
    -------------------------- :: unop_expr
    fm m cnt unop e --> fm m cnt' unop e'

    v' === [[ unop v ]]
    cnt' = succ cnt
    ----------------- :: unop_val
    fm m cnt unop v --> fm m cnt' v'

    fm m cnt e1 --> fm m cnt' e1'
    --------------------------- :: binop_l
    fm m cnt e1 binop e2 --> fm m cnt' e1' binop e2

    fm m cnt e2 --> fm m cnt' e2'
    -------------------------- :: binop_r
    fm m cnt v binop e2 --> fm m cnt' v binop e2'

    v3 === [[ v1 binop v2 ]]
    cnt' = succ cnt
    ----------------- :: binop_val
    fm m cnt v1 binop v2 --> fm m cnt' v3

    fm m cnt e1 --> fm m cnt' e1'
    ---------------------------- :: fn_expr
    fm m cnt f ( v1 , .. , vk , e1, e2 , .. , en ) --> fm m cnt' f ( v1 , .. , vk , e1' , e2 , .. , en )

    fm = fm' , f ( v1 , .. , vk ) = s ; return e
    ------------------------------ :: fn_call
    fm m cnt f ( v1 , .. , vk ) --> fm m cnt' e


defns
  Jpop :: '' ::=

    defn
    fm m cnt s --> fm' m' cnt' s' ::  :: stmt_reduce :: Str_ {{ com [[s]] reduces to [[s']] }}
    {{ tex \{[[fm]],[[m]],[[cnt]]\} [[s]] [[-->]] \{[[fm']],[[m']],[[cnt']]\} [[s']] }} by

    ------------------- :: skip
    fm m cnt skip ; s --> fm m cnt s

    fm m cnt s1 --> fm m' cnt' s1'
    -------------- :: seq
    fm m cnt s1 ; s2 --> fm m' cnt' s1' ; s2

    fm m cnt e --> fm m cnt' e'
    ------------- :: def_expr
    fm m cnt def x := e --> fm m cnt' def x := e'

    cnt' = succ cnt
    m' = m , x := v
    -----------------:: def_val
    fm m cnt def x := v --> fm m' cnt' skip

    fm m cnt e --> fm m cnt' e'
    --------------- :: assign_expr
    fm m cnt x := e --> fm m cnt' x := e'

    cnt' = succ cnt
    m' = m , x := v
    --------------- :: assign_val
    fm m cnt x := v --> fm m' cnt' skip

    v1 < v2
    v1' = succ v1
    not ( m = m' , x := v' )
    m'' = m , x := v1
    ------------------------- :: for
    fm m cnt for x from v1 to v2 : s --> fm m'' cnt s ; for x from v1' to v2 : s

    v1 = v2
    m' = m / x
    ---------------- :: for_base
    fm m cnt for x from v2 to v2 : s --> fm m' cnt skip
