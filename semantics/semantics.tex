\documentclass[11pt]{article}
\usepackage{amsmath,amssymb}
\usepackage{supertabular}
\usepackage{geometry}
\usepackage{ifthen}
\usepackage{alltt}%hack
\geometry{a4paper,dvips,twoside,left=22.5mm,right=22.5mm,top=20mm,bottom=30mm}
\usepackage{color}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{mathpartir}
\usepackage{mathtools}
\usepackage{etextools}
\usepackage{suffix}
\usepackage{comment}
\usepackage{fancyhdr}
\usepackage[en-US,showzone=false]{datetime2}
\usepackage{minibox}

\makeatletter
    \newcommand{\DeclarePairedDelimiterCase}[2]{%
        \newcommand#1[1][]{%
            \ifthenelse{\equal{##1}{normal}}%
            {#2}%
            {%
                \ifthenelse{\equal{##1}{big}\OR\equal{##1}{Big}\OR\equal{##1}{bigg}\OR\equal{##1}{Bigg}}%
                {\expandnext{#2[}{\csname##1\endcsname}]}%
                {#2*}%        % standard case using \left and \right
            }%
        }%
    }
    \newcommand{\DeclarePairedDelimiterY}[4][Temp]{%
        \expandafter\DeclarePairedDelimiter\csname#2#1\endcsname{#3}{#4}%
        \expandnext{\expandnext{\DeclarePairedDelimiterCase}{\csname#2\endcsname}}{\csname#2#1\endcsname}%
    }
    \newcommand{\DeclarePairedDelimiterXY}[6][Temp]{%
        \expandafter\DeclarePairedDelimiterX\csname#2#1\endcsname[#3]{#4}{#5}{#6}%
        \expandnext{\expandnext{\DeclarePairedDelimiterCase}{\csname#2\endcsname}}{\csname#2#1\endcsname}%
    }
\makeatother

\DeclarePairedDelimiterY{floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiterY{ceil}{\lceil}{\rceil}
\DeclarePairedDelimiterY{abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\vc}{\langle}{\rangle}

\newcommand\with{\,|\,}
\newcommand\has{\,\vdash\,}
\newcommand\stmto{\ \rightarrow\ }
\newcommand\sstep{\ \longrightarrow\ }
\newcommand\ssteplong{\ \longrightarrow^*\ }
\newcommand\sstepx[1]{\ \overset{#1}{\longrightarrow}\ }
\newcommand\estep{\ \xhookrightarrow{\quad}\ }
\newcommand\aug{\mapsto}
\newcommand\update{\Mapsto}
\newcommand\join{\sqcup}
\newcommand\meet{\sqcap}
\newcommand\tlt{\sqsubset}
\newcommand\tleq{\sqsubseteq}

\newcommand\huh{\,\texttt{?}\,}
\newcommand\helse{\,\texttt{:}\,}
\newcommand\huhelse{\,\texttt{?:}\,}

\newcommand\G\Gamma
\newcommand\F{\mathbb{F}}
\renewcommand\S\Sigma
\renewcommand\b{b}
\renewcommand\t\tau
\renewcommand\k\sigma
\renewcommand\l\ell
\newcommand\m\mu
\renewcommand\a\mu
\newcommand\M{\mathcal{M}}
\newcommand\ls{\l_s}
\newcommand\lx{\l^x}
\renewcommand\r{r}

\newcommand\Gm{\G \with \m}
\newcommand\T[1]{\vc{\t_{#1},\l_{#1},\k_{#1}}}
\newcommand\Tx[1]{\vc{\t_{#1},\lx_{#1},\k_{#1}}}

\newcommand\bool{\textsc{Bool}}
\newcommand\uint[1]{\textsc{UInt}_{#1}}
\WithSuffix\newcommand\uint*{\textsc{UInt}}
\renewcommand\int[1]{\textsc{Int}_{#1}}
\WithSuffix\newcommand\int*{\textsc{Int}}
\renewcommand\ref[1]{\textsc{Ref}\vc{#1}}
\WithSuffix\newcommand\ref*{\textsc{Ref}}
\newcommand\arr[1]{\textsc{Arr}\vc{#1}}
\WithSuffix\newcommand\arr*{\textsc{Arr}}

\newcommand\arrview[1]{\textsc{view}(#1)}

\newcommand\public{\textsc{Public}}
\newcommand\unknown{\textsc{Unknown}}
\newcommand\secret{\textsc{Secret}}
\newcommand\float[1]{\textsc{Float}\vc{#1}}

\newcommand\const{\textsc{Const}}
\newcommand\mut{\textsc{Mut}}

\newcommand\kref{\textsc{ref}}

\newcommand\ktrue{\textsc{true}}
\newcommand\kfalse{\textsc{false}}

\newcommand\kif{\textsc{if }}
\newcommand\kelse{\textsc{ else }}
\newcommand\kfor{\textsc{for }}
\newcommand\kfrom{\textsc{ from }}
\newcommand\kto{\textsc{ to }}
\newcommand\kret{\textsc{return }}
\newcommand\kskip{\textsc{skip}}

\newcommand{\ottcom}[1]{\text{#1}}
\newcommand{\grammar}[1]{\begin{supertabular}{lcll}#1\\\end{supertabular}}
\newcommand{\gramrule}[2]{\multicolumn{4}{l}{\textsc{#2}} \\ $#1$ & $::=$ }
\newcommand{\gramitem}[2][]{& $|$ & $#2$ & $\ottcom{#1}$}

\pagestyle{fancy}
\chead{\DTMnow}

\begin{document}

\subsubsection*{Grammar}

\begin{mathpar}

  \grammar
  { \gramrule{\b}{Base type} \\
    \gramitem{\bool} \\
    \gramitem{\uint{n}} \\
    \gramitem{\int{n}} }

  \grammar
  { \gramrule{\t}{Type} \\
    \gramitem{\b} \\
    \gramitem{\ref{\b}} \\
    \gramitem{\arr{\b,n}} \\
    \gramitem[$x$ must be $\vc{\ref{\uint*},\public,\const}$]{\arr{\b,x}} }

  \grammar
  { \gramrule{\l}{Label} \\
    \gramitem{\public} \\
    %\gramitem{\unknown} \\
    \gramitem{\secret} }

  \grammar
  { \gramrule{\lx}{Variable label} \\
    \gramitem{\l} \\
    \gramitem{\float{\l}} }

  \grammar
  { \gramrule{\k}{Mutability} \\
    \gramitem{\const} \\
    \gramitem{\mut} }

  \grammar
  { \gramrule{e}{Expression} \\
    \gramitem{\ktrue} \\
    \gramitem{\kfalse} \\
    \gramitem[integer literal]{c} \\
    \gramitem[variable]{x} \\
    \gramitem[array get]{x[e]} \\
    \gramitem[array comprehension]{\vc{\b,n,\b_x}x \Rightarrow e} \\
    \gramitem[array view]{\arrview{x,e,n}} \\
    \gramitem[unary op]{\ominus e} \\
    \gramitem[binary op]{e_1 \oplus e_2} \\
    \gramitem[ternary op]{e_1 \huh e_2 \helse e_3} \\
    \gramitem[mut ref]{\kref\ x} \\
    \gramitem[function call]{f(e_1,\dots,e_n)} }

  \grammar
  { \gramrule{s}{Statement} \\
    \gramitem[sequence]{s_1 ; s_2} \\
    \gramitem[variable declaration]{\vc{\ref{\b},\k} x = e} \\
    \gramitem[array declaration]{\vc{\arr{\b,n},\l,\k} x = e} \\
    \gramitem[variable assignment]{x := e} \\
    \gramitem[array assignment]{x[e_1] := e_2} \\
    \gramitem[conditional]{\kif e\ \{ s_1 \} \kelse \{ s_2 \}} \\
    \gramitem[loop]{\kfor \vc{\b} x \kfrom e_1 \kto e_2\ \{ s \}} \\
    \gramitem[return]{\kret e} }

  \grammar
  { \gramrule{fdec}{Function Definition} \\
    \gramitem{\vc{\b,\l} f ( \vc{\t_1,\l_1,\k_1}x_1 , \,\dots\, , \vc{\t_n,\l_n,\k_n}x_n )\ \{ s \}} }

\end{mathpar}

\subsubsection*{Metavariables}
\begin{mathpar}

  \grammar
  { \gramrule{\G}{Type context} \\
    \gramitem{\emptyset} \\
    \gramitem{\G [ e \aug \T{} ] } }

  \grammar
  { \gramrule{\mu}{Variable type store} \\
    \gramitem{\emptyset} \\
    \gramitem{\mu [ x \aug \Tx{} ] } }

  \grammar
  { \gramrule{\F}{Function type store} \\
    \gramitem{\emptyset} \\
    \gramitem{\F [ f \aug fdec (\T1, \,\dots\,, \T{n}) : \vc{\b,\l} ] } }

\end{mathpar}

\subsubsection*{Type Lattice}
\begin{mathpar}

  \infer
  { n_1 < n_2 }
  { \uint{n_1} \tlt \uint{n_2} }

  \infer
  { n_1 < n_2 }
  { \int{n_1} \tlt \int{n_2} }

  \infer { }
  { \uint{n} \tlt \int{2n} }

  \infer { }
  { \public \tlt \secret }

  \infer { }
  { \mut \tlt \const }

  % cannot upgrade base mut to base const
  % no subtyping allowed for mut -> mut
  \infer
  { \Gm \has e : \vc{\b,\l,\const} \\
    \b \tleq \b' \\
    \l \tleq \l' }
  { \Gm \has e : \vc{\b',\l',\const} }

  % subtyping can only upgrade to const
  % no subtyping allowed for mut -> mut
  \infer
  { \Gm \has e : \vc{\arr{\b,n},\l,\k} \\
    \l \tleq \l' }
  { \Gm \has e : \vc{\arr{\b,n},\l',\const} }

  % these arrays are no different
  \infer
  { \Gm \has e : \vc{\arr{\b,x},\l,\k} \\
    \l \tleq \l' }
  { \Gm \has e : \vc{\arr{\b,x},\l',\const} }

\end{mathpar}

\subsubsection*{Expressions \hfill \fbox{$\Gm \has e : \T{}$}}
\begin{mathpar}

  \infer[Var]
  { \m (x) = \vc{\ref{\b},\lx,\k} \\
    \lx = \l' \text{~~or~~} \lx = \float{\l'} }
  { \Gm \has x : \vc{\b,\l',\const} }

  \infer[ArrVar]
  { \m (x) = \vc{\arr{\b,n},\l,\k} }
  { \Gm \has x : \vc{\arr{\b,n},\l,\const} }

  \infer[Unop]
  { \Gm \has e : \T1 \\
    \ominus : \T1 \to \T2 }
  { \Gm \has \ominus e : \T2 }

  \infer[Binop]
  { \Gm \has e_1 : \T1 \\
    \Gm \has e_2 : \T2 \\
    \oplus : \T1 \to \T2 \to \T3 }
  { \Gm \has e_1 \oplus e_2 : \T3 }

  \infer[Ternop]
  { \Gm \has e_1 : \T1 \\
    \Gm \has e_2 : \T2 \\
    \Gm \has e_3 : \T3 \\
    (\!\huhelse\!\!) : \T1 \to \T2 \to \T3 \to \T4 }
  { \Gm \has e_1 \huh e_2 \helse e_3 : \T4 }

  % Instead of dynamic looping or masking,
  % just fall back to static analysis;
  % if we cannot determine statically that it's ok
  % then the program fails typechecking
  \infer[ArrGet]
  { \m (x) = \vc{\arr{\b,n},\l,\k} \\
    \Gm \has e : \vc{\uint*,\public,\const} \\
    S\hspace{-.7px}MT(e < n) }
  { \Gm \has x[e] : \vc{\b,\l,\const} }

  \infer[ArrGetDyn]
  { \m (x) = \vc{\arr{\b,x_n},\l,\k} \\
    \Gm \has e : \vc{\uint*,\public,\const} \\
    S\hspace{-.7px}MT(e < x_n) }
  { \Gm \has x[e] : \vc{\b,\l,\const} }

  \infer[ArrComp]
  { \Gm [ x \aug \vc{\b_x,\public,\const} ] \has e : \vc{\b,\l,\const} \\
    \uint{\ceil{\log_2 n}} \tleq \b_x }
  { \Gm \has \vc{\b,n,\b_x}x \Rightarrow e : \vc{\arr{\b,n},\l,\mut} }

  \infer[ArrView]
  { \m (x) = \vc{\arr{\b,n},\l,\k} \\
    \Gm \has e : \vc{\uint*,\public,\const} \\
    S\hspace{-.7px}MT(e + n' < n) }
  { \Gm \has \arrview{x,e,n'} : \vc{\arr{\b,n'},\l,\k} }

  \infer[ArrViewDyn]
  { \m (x) = \vc{\arr{\b,x_n},\l,\k} \\
    \Gm \has e : \vc{\uint*,\public,\const} \\
    S\hspace{-.7px}MT(e + n' < x_n) }
  { \Gm \has \arrview{x,e,n'} : \vc{\arr{\b,n'},\l,\k} }

  \infer[MutRef]
  { \m (x) = \vc{\t,\lx,\mut} \\
    \lx = \l' \text{~~or~~} \lx = \float{\l'} }
  { \Gm \has \kref\ x : \vc{\t,\l',\mut} }

  \infer[FnCall]
  { \F (f) = fdec (\T1, \,\dots\,, \T{n}) : \vc{\b,\l} \\
    \Gm \has e_1 : \T1 \\
    \dots \\
    \Gm \has e_n : \T{n} }
  { \Gm \has f(e_1,\,\dots\,,e_n) : \vc{\b,\l,\const} }

  \infer[True] { } { \Gm \has \ktrue : \vc{\bool,\public,\const} } \\
  \infer[False] { } { \Gm \has \kfalse : \vc{\bool,\public,\const} }

  \infer[PosNumber]
  { c >= 0 \\
    n = \ceil{\log_2 c} }
  { \Gm \has c : \vc{\uint{n},\public,\const} }

  \infer[NegNumber]
  { c < 0 \\
    n = \ceil{\log_2 \abs{c}}  + 1 }
  { \Gm \has c : \vc{\int{n},\public,\const} }

\end{mathpar}

\subsubsection*{Statements \hfill \fbox{$\vc{\m,\ls,\r} \has s \stmto \vc{\m',\ls',\r'}$}}
\begin{mathpar}

  \infer[Seq]
  { \vc{\m,\ls,\r} \has s_1 \stmto \vc{\m',\ls',\r'} \\
    \vc{\m',\ls',\r'} \has s_2 \stmto \vc{\m'',\ls'',\r''} }
  { \vc{\m,\ls,\r} \has s_1 ; s_2 \stmto \vc{\m'',\ls'',\r''} }

  % needed because in the general case (e.g. arrays), vardec Mut := Const is not allowed
  \infer[VarDecBaseMut]
  { x \notin Dom(\m) \\
    \Gm \has e : \vc{\b,\l,\const} }
  { \vc{\m,\l_s,\r} \has \vc{\ref{\b},\mut} x = e \stmto \vc{\m [ x \aug \vc{\ref{\b},\float{\l},\mut} ],\l_s,\r} }

  \infer[VarDec]
  { x \notin Dom(\m) \\
    \Gm \has e : \vc{\b,\l,\k} }
  { \vc{\m,\l_s,\r} \has \vc{\ref{\b},\k} x = e \stmto \vc{\m [ x \aug \vc{\ref{\b},\float{\l},\k} ],\l_s,\r} }

  \infer[ArrDec]
  { x \notin Dom(\m) \\
    \Gm \has e : \vc{\arr{\b,n},\l,\k} }
  { \vc{\m,\l_s,\r} \has \vc{\arr{\b,n},\l,\k} x = e \stmto \vc{\m [ x \aug \vc{\arr{\b,n},\l,\k} ],\l_s,\r} }

  \infer[VarAssign]
  { \mu (x) = \vc{\ref{\b},\l,\mut} \\
    \Gm \has e : \vc{\b,\l',\const} \\
    \ls \join \l' \tleq \l }
  { \vc{\m,\l_s,\r} \has x := e \stmto \vc{\m,\l_s,\r} }

  \infer[VarAssignFloat]
  { \mu (x) = \vc{\ref{\b},\float{\l},\mut} \\
    \Gm \has e : \vc{\b,\l',\const} }
  { \vc{\m,\l_s,\r} \has x := e \stmto \vc{\m [ x \aug \vc{\ref{\b},\float{\l'},\mut} ],\l_s,\r} }

  \infer[ArrAssign]
  { \mu (x) = \vc{\arr{\b,n},\l,\mut} \\
    \Gm \has e_1 : \vc{\uint*,\public,\const} \\
    S\hspace{-.7px}MT(e_1 < n) \\
    \Gm \has e_2 : \vc{\b,\l',\const} \\
    \ls \join \l' \tleq \l }
  { \vc{\m,\l_s,\r} \has x[e_1] := e_2 \stmto \vc{\m,\l_s,\r} }

  \infer[ArrAssignDyn]
  { \mu (x) = \vc{\arr{\b,x_n},\l,\mut} \\
    \Gm \has e_1 : \vc{\uint*,\public,\const} \\
    S\hspace{-.7px}MT(e_1 < x_n) \\
    \Gm \has e_2 : \vc{\b,\l',\const} \\
    \ls \join \l' \tleq \l }
  { \vc{\m,\l_s,\r} \has x[e_1] := e_2 \stmto \vc{\m,\l_s,\r} }

  \infer[If]
  { \Gm \has e : \vc{\bool,\l,\k} \\\\
    \vc{\m,\l_s,\r} \has s_1 \stmto \vc{\m',\ls',\r'} \\
    \vc{\m,\l_s,\r} \has s_2 \stmto \vc{\m'',\ls'',\r''} \\\\
    \m^* = join\m(\m,\m',\m'',\l) \\
    \ls^*,\r^* = join\ls\r(\ls,\ls',\ls'',\r,\r',\r'') }
  { \vc{\m,\l_s,\r} \has \kif e\ \{ s_1 \} \kelse \{ s_2 \} \stmto \vc{\m^*,\ls^*,\r^*} }

  \infer[For]
  { \Gm \has e_1 : \vc{\b,\public,\const} \\
    \Gm \has e_2 : \vc{\b,\public,\const} \\
    \b = \uint* \text{ or } \b = \int* \\
    \vc{\m [ x \aug \vc{\ref{\b},\public,\const} ],\ls,\r} \has s \stmto \vc{\m',\ls',\r'} \\
    \m'' = scoping(\mu,\mu') }
  { \vc{\m,\ls,\r} \has \kfor \vc{\b} x \kfrom e_1 \kto e_2\ \{ s \} \stmto \vc{\m'',\ls',\r'} }

  \infer[Ret]
  { \F (f) = fdec : \vc{\b,\l_1} \\
    \Gm \has e : \vc{\b,\l_2} }
  { \vc{\m,\ls,\r} \has \kret e \stmto \vc{\m,\ls,\ktrue} }

\end{mathpar}

\subsubsection*{Interesting Semantics \hfill \minibox[c,frame]{$\S,\a,s \sstep \S',\a',s'$ \\ $\S,\a,e \estep \S',\a',e'$}}
\begin{mathpar}

  \infer[Seq]
  { \S,\a,s_1 \sstep \S',\a',s_1' }
  { \S,\a,s_1 ; s_2 \sstep \S',\a',s_1' ; s_2 }

  \infer[Skip]
  { }
  { \S,\a,\kskip ; s_2 \sstep \S,\a,s_2 }

  \infer[Ret]
  { }
  { \S,\a,\kret v ; s_2 \sstep \S,\a,\kret v }

  \infer[VarDec]
  { \S' = \S[x \aug r] \\
    \a' = \a[r \aug v] \\
    \text{fresh $r$} }
  { \S,\a,\vc{\t,\cdot,\k} x = v \sstep \S',\a',\kskip }

  \infer[VarAssign]
  { \a' = \a[r \aug v] }
  { \S,\a,r := v \sstep \S,\a',\kskip }

  \infer[IfTrue]
  { v = \ktrue }
  { \S,\a,\kif v\ \{ s_1 \} \kelse \{ s_2 \} \sstep \S,\a,s_1 }

  \infer[IfFalse]
  { v = \kfalse }
  { \S,\a,\kif v\ \{ s_1 \} \kelse \{ s_2 \} \sstep \S,\a,s_2 }

  \infer[ForIter]
  { v_1 < v_2 \\
    v_1' = v_1 + 1 }
  { \S,\a,\kfor \vc{\b} x \kfrom v_1 \kto v_2\ \{ s \}
      \sstep \S,\a,s[x \aug v_1] ; \kfor \vc{\b} x \kfrom v_1' \kto v_2\ \{ s \} }

  \infer[ForEnd]
  { v_1 \geq v_2 }
  { \S,\a,\kfor \vc{\b} x \kfrom v_1 \kto v_2\ \{ s \} \sstep \S,\a,\kskip }

  \infer[Var]
  { \S(x) = r \\
    \a(r) = v }
  { \S,\a,x \estep \S,\a,v }

  \infer[Ref]
  { \S(x) = r }
  { \S,\a,\kref\ x \estep \S,\a,r }

  \infer[FnCall]
  { \F(f) = fdec\ f(x_1,\dots,x_n)\ \{ s \} \\
    \S_0 = \{ x_1 \aug r_1, \dots, x_n \aug r_n \} \\
    \text{fresh $r_i$s when necessary} \\
    \S_0,\a,s \ssteplong \S_0',\a',\kret v \\
    \a'' = copyback(\a,\a') }
  { \S,\a,f(v_1,\dots,v_n) \estep \S,\a'',v }

\end{mathpar}

\end{document}
