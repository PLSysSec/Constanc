\documentclass[11pt]{article}
\usepackage{amsmath,amssymb}
\usepackage{supertabular}
\usepackage{geometry}
\usepackage{ifthen}
\usepackage{alltt}%hack
\geometry{a4paper,dvips,twoside,left=22.5mm,right=22.5mm,top=20mm,bottom=30mm}
\usepackage{color}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{mathpartir}
\usepackage{mathtools}
\usepackage{etextools}

\makeatletter
    \newcommand{\DeclarePairedDelimiterCase}[2]{%
        \newcommand#1[1][]{%
            \ifthenelse{\equal{##1}{normal}}%
            {#2}%
            {%
                \ifthenelse{\equal{##1}{big}\OR\equal{##1}{Big}\OR\equal{##1}{bigg}\OR\equal{##1}{Bigg}}%
                {\expandnext{#2[}{\csname##1\endcsname}]}%
                {#2*}%        % standard case using \left and \right
            }%
        }%
    }
    \newcommand{\DeclarePairedDelimiterY}[4][Temp]{%
        \expandafter\DeclarePairedDelimiter\csname#2#1\endcsname{#3}{#4}%
        \expandnext{\expandnext{\DeclarePairedDelimiterCase}{\csname#2\endcsname}}{\csname#2#1\endcsname}%
    }
    \newcommand{\DeclarePairedDelimiterXY}[6][Temp]{%
        \expandafter\DeclarePairedDelimiterX\csname#2#1\endcsname[#3]{#4}{#5}{#6}%
        \expandnext{\expandnext{\DeclarePairedDelimiterCase}{\csname#2\endcsname}}{\csname#2#1\endcsname}%
    }
\makeatother

\DeclarePairedDelimiterY{floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiterY{ceil}{\lceil}{\rceil}
\DeclarePairedDelimiterY{abs}{\lvert}{\rvert}
\DeclarePairedDelimiterY{vc}{\langle}{\rangle}

\newcommand\has\vdash
\newcommand\stmto{\ \Longrightarrow\ }

\newcommand\G\Gamma
\newcommand\F{\mathbb{F}}
\newcommand\Z{\mathbb{Z}}
\renewcommand\t\tau
\renewcommand\k{k}
\renewcommand\l\ell
\newcommand\m\mu
\newcommand\M{\mathcal{M}}

\newcommand\public{\textsc{Public}}
\newcommand\secret{\textsc{Secret}}
\newcommand\val{\textsc{Val}}
\renewcommand\ref{\textsc{Ref}}
\newcommand\arr[1]{\textsc{Arr}\vc{#1}}

\newcommand\kif{\textnormal{if }}
\newcommand\kelse{\textnormal{ else }}
\newcommand\kfor{\textnormal{for }}
\newcommand\kfrom{\textnormal{ from }}
\newcommand\kto{\textnormal{ to }}
\newcommand\kret{\textnormal{return }}

\begin{document}

\subsubsection*{Type Lattice}
\begin{mathpar}

  \infer
  { s_1 < s_2 }
  { uint\vc{s_1} <_\tau uint\vc{s_2} }

  \infer
  { s_1 < s_2 }
  { int\vc{s_1} <_\tau int\vc{s_2} }

  \infer { }
  { uint\vc{s} <_\tau int\vc{2s} }

  \infer
  { \t_1 <_\tau \t_2 \\
    \Gamma \has e : \vc{\t_1, \ell} }
  { \Gamma \has e : \vc{\t_2, \ell} }

  \infer { }
  { \public <_\ell \secret }

  \infer
  { \ell_1 \leq_\ell \ell_2 }
  { \ell_1 \cup \ell_2 = \ell_2 }

\end{mathpar}

\subsubsection*{Expressions}
\begin{mathpar}

  \infer[Var]
  { \m (x) = \vc{\tau,\ell,\k} \\
    \k \neq \arr{s} }
  { \G \has x : \vc{\tau,\ell} }

  \infer[Unop]
  { \G \has e : \vc{\tau,\ell} \\
    \ominus : \tau \to \tau }
  { \G \has \ominus e : \vc{\tau,\ell} }

  \infer[Binop]
  { \G \has e_1 : \vc{\tau_1,\ell_1} \\
    \G \has e_2 : \vc{\tau_2,\ell_2} \\
    \oplus : \tau_1 \to \tau_2 \to \tau_3 }
  { \G \has e_1 \oplus e_2 : \vc{\tau_3, \ell_1 \cup \ell_2 } }

  \infer[ArrGet]
  { \m (a) = \vc{\tau,\ell,\arr{s}} \\
    \G \has e : uint\vc{max}_\public }
  { \G \has a[e] : \vc{\t,\l} }

  \infer[ValPass]
  { p : \vc{\t,\l_1,\val} \\
    \G \has e : \vc{\t,\l_2} \\
    \l_2 \leq_\l \l_1 }
  { p \gets e }

  \infer[RefPassSecret]
  { p : \vc{\t,\secret,\ref} \\
    \m (x) = \vc{\tau,\l,\k} \\
    \k \neq \arr{s} }
  { p \gets x }

  \infer[RefPassPublic]
  { p : \vc{\t,\public,\ref} \\
    \m (x) = \vc{\tau,\public,\k} \\
    \k \neq \arr{s} }
  { p \gets x }

  \infer[ArrPassSecret]
  { p : \vc{\t,\secret,\arr{s}} \\
    \m (a) = \vc{\tau,\l,\arr{s}} }
  { p \gets a }

  \infer[ArrPassPublic]
  { p : \vc{\t,\public,\arr{s}} \\
    \m (a) = \vc{\tau,\public,\arr{s}} }
  { p \gets a }

  \infer[ArrPassSecretSlice]
  { p : \vc{\t,\secret,\arr{s_1}} \\
    \m (a) = \vc{\tau,\l,\arr{s_2}} \\
    s_1 \leq s_2 }
  { p \gets a[n:n+s_1] }

  \infer[ArrPassPublicSlice]
  { p : \vc{\t,\public,\arr{s_1}} \\
    \m (a) = \vc{\tau,\public,\arr{s_2}} \\
    s_1 \leq s_2 }
  { p \gets a[n:n+s_1] }

  \infer[FnCall]
  { \F (f) = fdec (p_1:\vc{\t_1,\l_1,\k_1}, \dots, p_n:\vc{\t_n,\l_n,\k_n}) : \vc{\t_r,\l_r} \\
    p_1 \gets v_1 \\ \cdots \\ p_n \gets v_n }
  { \G \has f(v_1,\dots,v_n) : \vc{\t_r,\l_r} }

  \infer[True] { } { \Gamma \has true : \vc{bool,\public} } \\
  \infer[False] { } { \Gamma \has false : \vc{bool,\public} }

  \textnormal{Array literals are not expressions since they can only be used with \textsc{ArrDec}.}

  \infer[PosNumber]
  { n >= 0 \\
    s = \ceil{\log_2 n} }
  { \Gamma \has n : \vc{uint\vc{s},\public} }

  \infer[NegNumber]
  { n < 0 \\
    s = \ceil{\log_2 \abs{n}}  + 1 }
  { \Gamma \has n : \vc{int\vc{s},\public} }

\end{mathpar}

\subsubsection*{Statements}
\begin{mathpar}

  \newcommand\stmtitle{}
  \newcommand\stt[1]{\renewcommand\stmtitle{$#1 \stmto$}}
  \newcommand\xinfer[3]{\stt{#1}\infer[\stmtitle]{#2}{#3}}

  \xinfer{\vc{\t,\l_x} x := e} % VarDec
  { x \notin \mu \\
    \G \has e : \vc{\t,\l_e} \\
    \l_e \leq_\l \l_x }
  { \mu (x) := \vc{\t,\l_x,\val} \\
    \M (x) := e }

  \xinfer{\vc{\t,\l_a} a[s] := \textsc{ArrayInitializer}} % ArrDec
  { a \notin \mu \\
    \textsc{ArrayInitializer} : \vc{\t,\l_e} \\
    \l_e \leq_\l \l_a }
  { \mu (a) := \vc{\t,\l_a,\arr{s}} \\
    \M (a) := \textsc{ArrayInitializer} }

  \xinfer{x := e} % VarAssign
  { \mu (x) = \vc{\t,\l_x,\k} \\
    \k \neq \arr{s} \\
    \G \has e : \vc{\t,\l_e} \\
    \l_e \leq_\l \l_x }
  { \M (x) := e }

  \xinfer{a[e_1] := e_2} % ArrAssign
  { \mu (a) = \vc{\t,\l_x,\k} \\
    \k = \arr{s} \\
    \G \has e_1 : \vc{uint\vc{max},\public} \\
    \G \has e_2 : \vc{\t,\l_e} \\
    \l_e \leq_\l \l_x }
  { \M (a,e_1) := e_2 }

  \xinfer{\kif (e) \{ s_1 \} \kelse \{ s_2 \}} % If
  { \G \has e : \vc{bool,\l} }
  { }

  \xinfer{\kfor (\vc{\t,\public}i \kfrom e_1 \kto e_2) \{ s \}} % For
  { i \notin \mu \\
    \G \has e_1 : \vc{\t,\public} \\
    \G \has e_2 : \vc{\t,\public} }
  { }

  \xinfer{\kret e} % Ret
  { \G \has e : \vc{\t,\l_e} \\
    \F (f) = fdec : \vc{\t,\l_f} \\
    \l_e \leq_\l \l_f }
  { }

\end{mathpar}
\end{document}
