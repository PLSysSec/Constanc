\documentclass[11pt]{article}
\usepackage{amsmath,amssymb}
\usepackage{supertabular}
\usepackage{geometry}
\usepackage{ifthen}
\usepackage{alltt}%hack
\geometry{a4paper,dvips,twoside,left=22.5mm,right=22.5mm,top=20mm,bottom=30mm}
\usepackage{color}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{mathpartir}
\usepackage{mathtools}
\usepackage{etextools}
\usepackage{suffix}
\usepackage{comment}
\usepackage{fancyhdr}
\usepackage[en-US,showzone=false]{datetime2}

\makeatletter
    \newcommand{\DeclarePairedDelimiterCase}[2]{%
        \newcommand#1[1][]{%
            \ifthenelse{\equal{##1}{normal}}%
            {#2}%
            {%
                \ifthenelse{\equal{##1}{big}\OR\equal{##1}{Big}\OR\equal{##1}{bigg}\OR\equal{##1}{Bigg}}%
                {\expandnext{#2[}{\csname##1\endcsname}]}%
                {#2*}%        % standard case using \left and \right
            }%
        }%
    }
    \newcommand{\DeclarePairedDelimiterY}[4][Temp]{%
        \expandafter\DeclarePairedDelimiter\csname#2#1\endcsname{#3}{#4}%
        \expandnext{\expandnext{\DeclarePairedDelimiterCase}{\csname#2\endcsname}}{\csname#2#1\endcsname}%
    }
    \newcommand{\DeclarePairedDelimiterXY}[6][Temp]{%
        \expandafter\DeclarePairedDelimiterX\csname#2#1\endcsname[#3]{#4}{#5}{#6}%
        \expandnext{\expandnext{\DeclarePairedDelimiterCase}{\csname#2\endcsname}}{\csname#2#1\endcsname}%
    }
\makeatother

\DeclarePairedDelimiterY{floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiterY{ceil}{\lceil}{\rceil}
\DeclarePairedDelimiterY{abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\vc}{\langle}{\rangle}

\newcommand\with{\,|\,}
\newcommand\has{\,\vdash\,}
\newcommand\stmto{\ \rightarrow\ }
\newcommand\aug{\mapsto}

\newcommand\G\Gamma
\newcommand\F{\mathbb{F}}
\renewcommand\S\Delta
\renewcommand\b{b}
\renewcommand\t\tau
\renewcommand\k\sigma
\renewcommand\l\ell
\newcommand\m\mu
\newcommand\M{\mathcal{M}}
\renewcommand\r{r_?}

\newcommand\Gm{\G \with \m}
\newcommand\T[1]{\vc{\t_{#1},\l_{#1},\k_{#1}}}

\newcommand\bool{\textsc{Bool}}
\newcommand\uint[1]{\textsc{UInt}_{#1}}
\WithSuffix\newcommand\uint*{\textsc{UInt}}
\renewcommand\int[1]{\textsc{Int}_{#1}}
\newcommand\arr[1]{\textsc{Arr}\vc{#1}}
\WithSuffix\newcommand\arr*{\textsc{Arr}}

\newcommand\arrview[1]{\textsc{view}(#1)}

\newcommand\public{\textsc{Public}}
\newcommand\unknown{\textsc{Unknown}}
\newcommand\secret{\textsc{Secret}}

\newcommand\const{\textsc{Const}}
\newcommand\mut{\textsc{Mut}}

\renewcommand\ref{\textsc{ref}}

\newcommand\ktrue{\textsc{true}}
\newcommand\kfalse{\textsc{false}}

\newcommand\kif{\textsc{if }}
\newcommand\kelse{\textsc{ else }}
\newcommand\kfor{\textsc{for }}
\newcommand\kfrom{\textsc{ from }}
\newcommand\kto{\textsc{ to }}
\newcommand\kret{\textsc{return }}

\newcommand{\ottcom}[1]{\text{#1}}
\newcommand{\grammar}[1]{\begin{supertabular}{lcll}#1\\\end{supertabular}}
\newcommand{\gramrule}[2]{\multicolumn{4}{l}{\textsc{#2}} \\ $#1$ & $::=$ }
\newcommand{\gramitem}[2][]{& $|$ & $#2$ & $\ottcom{#1}$}

\pagestyle{fancy}
\chead{\DTMnow}

\begin{document}

\subsubsection*{Grammar}

\begin{mathpar}

  \grammar
  { \gramrule{\b}{Base type} \\
    \gramitem{\bool} \\
    \gramitem{\uint{n}} \\
    \gramitem{\int{n}} }

  \grammar
  { \gramrule{\t}{Type} \\
    \gramitem{\b} \\
    \gramitem{\arr{\b,n}} }

  \grammar
  { \gramrule{\l}{Label} \\
    \gramitem{\public} \\
    %\gramitem{\unknown} \\
    \gramitem{\secret} }

  \grammar
  { \gramrule{\k}{Mutability} \\
    \gramitem{\const} \\
    \gramitem{\mut} }

  \grammar
  { \gramrule{e}{Expression} \\
    \gramitem{\ktrue} \\
    \gramitem{\kfalse} \\
    \gramitem[integer literal]{c} \\
    \gramitem[variable]{x} \\
    \gramitem[array get]{x[e]} \\
    \gramitem[array comprehension]{\vc{\t,n}x \Rightarrow e} \\
    \gramitem[array view]{\arrview{x,e,n}} \\
    \gramitem[unary op]{\ominus e} \\
    \gramitem[binary op]{e_1 \oplus e_2} \\
    \gramitem[mut ref]{\ref\ x} \\
    \gramitem[function call]{f(e_1,\dots,e_n)} }

  \grammar
  { \gramrule{s}{Statement} \\
    \gramitem[sequence]{s_1 ; s_2} \\
    \gramitem[variable declaration]{\vc{\t,\l,\k} x := e} \\
    \gramitem[variable assignment]{x := e} \\
    \gramitem[array assignment]{x[e_1] = e_2} \\
    \gramitem[conditional]{\kif e\ \{ s_1 \} \kelse \{ s_2 \}} \\
    \gramitem[loop]{\kfor \vc{\b} x \kfrom e_1 \kto e_2\ \{ s \}} \\
    \gramitem[return]{\kret e} }

  \grammar
  { \gramrule{fdec}{Function Definition} \\
    \gramitem{\vc{\b,\l} f ( \vc{\t_1,\l_1,\k_1}x_1 , \,\dots\, , \vc{\t_n,\l_n,\k_n}x_n )\ \{ s \}} }

\end{mathpar}

\subsubsection*{Type Lattice}
\begin{mathpar}

  \infer
  { n_1 < n_2 }
  { \uint{n_1} <_\t \uint{n_2} }

  \infer
  { n_1 < n_2 }
  { \int{n_1} <_\t \int{n_2} }

  \infer { }
  { \uint{n} <_\t \int{2n} }

  \infer { }
  { \public <_\l \secret }

  \infer { }
  { \mut <_\k \const }

  \infer
  { \Gm \has e : \T1 \\
    \t_1 \leq_\t \t_2 \\
    \l_1 \leq_\l \l_2 \\
    \k_1 \leq_\k \k_2 }
  { \Gm \has e : \T2 }

  \infer { }
  { \l \cup \l = \l }

  \infer { }
  { \l \cup \secret = \secret }

  \infer { }
  { \secret \cup \l = \secret }

\end{mathpar}

\subsubsection*{Expressions}
\begin{mathpar}

  \infer[Var]
  { \m (x) = \vc{\t,\l,\k} }
  { \Gm \has x : \vc{\t,\l,\const} }

  \infer[Unop]
  { \Gm \has e : \T1 \\
    \ominus : \T1 \to \T2 }
  { \Gm \has \ominus e : \T2 }

  \infer[Binop]
  { \Gm \has e_1 : \T1 \\
    \Gm \has e_2 : \T2 \\
    \oplus : \T1 \to \T2 \to \T3 }
  { \Gm \has e_1 \oplus e_2 : \T3 }

  % Instead of dynamic looping or masking,
  % just fall back to static analysis;
  % if we cannot determine statically that it's ok
  % then the program fails typechecking
  \infer[ArrGet]
  { \m (x) = \vc{\arr{\b,n},\l,\k} \\
    \Gm \has e : \vc{\uint*,\public,\const} \\
    S\hspace{-.7px}MT(e < n) }
  { \Gm \has x[e] : \vc{\b,\l,\const} }

  \infer[ArrComp]
  { \Gm [ x \aug \vc{\b,\l,\const} ] \has e : \vc{\b,\l,\k} }
  { \Gm \has \vc{\b,n}x \Rightarrow e : \vc{\arr{\b,n},\l,\mut} }

  \infer[ArrView]
  { \m (x) = \vc{\arr{\b,n},\l,\k} \\
    \Gm \has e : \vc{\uint*,\public,\const} \\
    S\hspace{-.7px}MT(e + n' < n) }
  { \Gm \has \arrview{x,e,n'} : \vc{\arr{\b,n'},\l,\k} }

  \infer[MutRef]
  { \m (x) = \vc{\t,\l,\mut} }
  { \Gm \has \ref\ x : \vc{\t,\l,\mut} }

  \infer[FnCall]
  { \F (f) = fdec (\T1, \,\dots\,, \T{n}) : \T{f} \\
    \Gm \has e_1 : \T1 \\
    \dots \\
    \Gm \has e_n : \T{n} }
  { \Gm \has f(e_1,\,\dots\,,e_n) : \T{f} }

  \infer[True] { } { \Gm \has \ktrue : \vc{\bool,\public,\const} } \\
  \infer[False] { } { \Gm \has \kfalse : \vc{\bool,\public,\const} }

  \infer[PosNumber]
  { c >= 0 \\
    n = \ceil{\log_2 c} }
  { \Gm \has c : \vc{\uint{n},\public,\const} }

  \infer[NegNumber]
  { c < 0 \\
    n = \ceil{\log_2 \abs{c}}  + 1 }
  { \Gm \has c : \vc{\int{n},\public,\const} }

\end{mathpar}

\subsubsection*{Statements}
\begin{mathpar}

  \infer[Seq]
  { \S \has s_1 \stmto \S' \\
    \S' \has s_2 \stmto \S'' }
  { \S \has s_1 ; s_2 \stmto \S'' }

  \infer[VarDec]
  { x \notin Dom(\m) \\
    \l_s \leq_\l \l \\
    \Gm \has e : \T{} }
  { \vc{\m,\l_s,\r} \has \T{} x := e \stmto \vc{\m \aug x : \T{},\l_s,\r} }

  \infer[VarDec*]
  { x \notin Dom(\m) \\
    \l_s \leq_\l \l \\
    \Gm \has e : \vc{\b,\l,\const} }
  { \vc{\m,\l_s,\r} \has \vc{\b,\l,\mut} x := e \stmto \vc{\m \aug x : \vc{\b,\l,\mut},\l_s,\r} }

  \infer[VarAssign]
  { \mu (x) = \vc{\b,\l,\mut} \\
    \Gm \has e : \vc{\b,\l,\const} }
  { \S\vc{\l_s} \has x := e : \public }

  \infer[ArrAssign]
  { \mu (a) = \vc{\arr{\b,n},\l_1,\mut} \\
    \G \has e_1 : \vc{\uint{max},\public} \\
    \G \has e_2 : \vc{\b,\l_2} \\
    \l_2 \leq_\l \l_1 }
  { \S\vc{\l_s} \has a[e_1] := e_2 : \public }

  \infer[If]
  { \G \has e : \vc{\bool,\l} \\
    \S\vc{\l \cup \l_s} \has s_1 : \l'_s \\
    \S\vc{\l \cup \l_s} \has s_2 : \l''_s }
  { \S\vc{\l_s} \has \kif e\ \{ s_1 \} \kelse \{ s_2 \} : \l'_s \cup \l''_s }

  \infer[For]
  { \G \has e_1 : \vc{\b,\public} \\
    \G \has e_2 : \vc{\b,\public} \\
    \b = \uint{s} \lor \b = \int{s} \\
    \S\vc{\l_s} \has s : \l'_s }
  { \S\vc{\l_s} \has \kfor \vc{\b} x \kfrom e_1 \kto e_2\ \{ s \} : \l'_s \\\\
    \mu (x) = \vc{\b,\public,\const} \text{\tiny\ (scoping?)}}

  \infer[Ret]
  { \G \has e : \vc{\b,\l_1} \\
    \F (f) = fdec : \vc{\b,\l_2} \\
    \l_1 \leq_\l \l_2 }
  { \S\vc{\l_s} \has \kret e : \l_s }

\end{mathpar}
\end{document}
