\documentclass[11pt]{article}
\usepackage{amsmath,amssymb}
\usepackage{supertabular}
\usepackage{geometry}
\usepackage{ifthen}
\usepackage{alltt}%hack
\geometry{a4paper,dvips,twoside,left=22.5mm,right=22.5mm,top=20mm,bottom=30mm}
\usepackage{color}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{mathpartir}
\usepackage{mathtools}
\usepackage{etextools}
\usepackage{suffix}

\makeatletter
    \newcommand{\DeclarePairedDelimiterCase}[2]{%
        \newcommand#1[1][]{%
            \ifthenelse{\equal{##1}{normal}}%
            {#2}%
            {%
                \ifthenelse{\equal{##1}{big}\OR\equal{##1}{Big}\OR\equal{##1}{bigg}\OR\equal{##1}{Bigg}}%
                {\expandnext{#2[}{\csname##1\endcsname}]}%
                {#2*}%        % standard case using \left and \right
            }%
        }%
    }
    \newcommand{\DeclarePairedDelimiterY}[4][Temp]{%
        \expandafter\DeclarePairedDelimiter\csname#2#1\endcsname{#3}{#4}%
        \expandnext{\expandnext{\DeclarePairedDelimiterCase}{\csname#2\endcsname}}{\csname#2#1\endcsname}%
    }
    \newcommand{\DeclarePairedDelimiterXY}[6][Temp]{%
        \expandafter\DeclarePairedDelimiterX\csname#2#1\endcsname[#3]{#4}{#5}{#6}%
        \expandnext{\expandnext{\DeclarePairedDelimiterCase}{\csname#2\endcsname}}{\csname#2#1\endcsname}%
    }
\makeatother

\DeclarePairedDelimiterY{floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiterY{ceil}{\lceil}{\rceil}
\DeclarePairedDelimiterY{abs}{\lvert}{\rvert}
\DeclarePairedDelimiterY{vc}{\langle}{\rangle}

\newcommand\has\vdash
\newcommand\stmto{\ \Longrightarrow\ }

\newcommand\G\Gamma
\newcommand\F{\mathbb{F}}
\newcommand\Z{\mathbb{Z}}
\renewcommand\t\tau
\renewcommand\k\sigma
\renewcommand\l\ell
\newcommand\m\mu
\newcommand\M{\mathcal{M}}

\newcommand\bool{\textsc{Bool}}
\newcommand\uint[1]{\textsc{UInt}\vc{#1}}
\renewcommand\int[1]{\textsc{Int}\vc{#1}}

\newcommand\public{\textsc{Public}}
\newcommand\unknown{\textsc{Unknown}}
\newcommand\secret{\textsc{Secret}}

\newcommand\val{\textsc{Val}}
\renewcommand\ref{\textsc{Ref}}
\newcommand\arr[1]{\textsc{Arr}\vc{#1}}
\WithSuffix\newcommand\arr*{\textsc{Arr}}

\newcommand\kif{\textnormal{if }}
\newcommand\kelse{\textnormal{ else }}
\newcommand\kfor{\textnormal{for }}
\newcommand\kfrom{\textnormal{ from }}
\newcommand\kto{\textnormal{ to }}
\newcommand\kret{\textnormal{return }}

\begin{document}

\subsubsection*{Types}
\begin{mathpar}

  \inferrule[Base Type $\t$]{}
  { \bool \\
    \uint{s} \\
    \int{s} }

  \infer[Label $\l$]{}
  { \public \\
    %\unknown \\
    \secret }

  \infer[Storage Type $\k$]{}
  { \val \\
    \ref \\
    \arr{s} }

\end{mathpar}

\subsubsection*{Type Lattice}
\begin{mathpar}

  \infer
  { s_1 < s_2 }
  { \uint{s_1} <_\tau \uint{s_2} }

  \infer
  { s_1 < s_2 }
  { \int{s_1} <_\tau \int{s_2} }

  \infer { }
  { \uint{s} <_\tau \int{2s} }

  \infer
  { \t_1 <_\tau \t_2 \\
    \Gamma \has e : \vc{\t_1, \ell} }
  { \Gamma \has e : \vc{\t_2, \ell} }

  \infer { }
  { \public <_\ell \secret }

  \infer
  { \ell_1 \leq_\ell \ell_2 }
  { \ell_1 \cup \ell_2 = \ell_2 }

\end{mathpar}

\subsubsection*{Parameter Passing}
\begin{mathpar}

  \infer
  { \G \has e : \vc{\t,\l_1} \\
    \l_1 \leq_\l \l_2 }
  { \vc{\t,\l_2,\val} \gets \val\ e }

  \infer
  { \m (x) = \vc{\tau,\l,\k} \\
    \k \neq \arr{s} }
  { \vc{\t,\l,\ref} \gets \ref\ x }

  \infer
  { \m (a) = \vc{\tau,\l,\arr{s}} }
  { \vc{\t,\l,\arr{s}} \gets \arr*\ a }

  \infer
  { \m (a) = \vc{\tau,\l,\arr{s_1}} \\
    s_2 \leq s_1 \\
    n' = n + s_2 \\
    n' \leq s_1 }
  { \vc{\t,\l,\arr{s_2}} \gets \arr*\ a[n:n'] }

\end{mathpar}

\subsubsection*{Expressions}
\begin{mathpar}

  \infer[Var]
  { \m (x) = \vc{\tau,\ell,\k} \\
    \k \neq \arr{s} }
  { \G \has x : \vc{\tau,\ell} }

  \infer[Unop]
  { \G \has e : \vc{\tau_1,\ell} \\
    \ominus : \tau_1 \to \tau_2 }
  { \G \has \ominus e : \vc{\tau_2,\ell} }

  \infer[Binop]
  { \G \has e_1 : \vc{\tau_1,\ell_1} \\
    \G \has e_2 : \vc{\tau_2,\ell_2} \\
    \oplus : \tau_1 \to \tau_2 \to \tau_3 }
  { \G \has e_1 \oplus e_2 : \vc{\tau_3, \ell_1 \cup \ell_2 } }

  \infer[ArrGet]
  { \m (a) = \vc{\tau,\ell,\arr{s}} \\
    \G \has e : \vc{\uint{max},\public} }
  { \G \has a[e] : \vc{\t,\l} }

  \infer[FnCall]
  { \F (f) = fdec (p_1, \dots, p_n) : \vc{\t,\l} \\
    p_1 \gets v_1 \\ \cdots \\ p_n \gets v_n }
  { \G \has f(v_1,\dots,v_n) : \vc{\t,\l} }

  \infer[True] { } { \Gamma \has true : \vc{bool,\public} } \\
  \infer[False] { } { \Gamma \has false : \vc{bool,\public} }

  \infer[PosNumber]
  { n >= 0 \\
    s = \ceil{\log_2 n} }
  { \Gamma \has n : \vc{\uint{s},\public} }

  \infer[NegNumber]
  { n < 0 \\
    s = \ceil{\log_2 \abs{n}}  + 1 }
  { \Gamma \has n : \vc{\int{s},\public} }

\end{mathpar}

\subsubsection*{Statements}
\begin{mathpar}

  \newcommand\stmtitle{}
  \newcommand\stt[1]{\renewcommand\stmtitle{$#1 \stmto$}}
  \newcommand\xinfer[3]{\stt{#1}\infer[\stmtitle]{#2}{#3}}

  \xinfer{\vc{\t,\l_x} x := e} % VarDec
  { x \notin \mu \\
    \G \has e : \vc{\t,\l_e} \\
    \l_e \leq_\l \l_x }
  { \mu (x) := \vc{\t,\l_x,\val} \\
    \M (x) := e }

  \xinfer{\vc{\t,\l_a} a[s] := \textsc{ArrayInitializer}} % ArrDec
  { a \notin \mu \\
    \textsc{ArrayInitializer} : \vc{\t,\l_e} \\
    \l_e \leq_\l \l_a }
  { \mu (a) := \vc{\t,\l_a,\arr{s}} \\
    \M (a) := \textsc{ArrayInitializer} }

  \xinfer{x := e} % VarAssign
  { \mu (x) = \vc{\t,\l_x,\k} \\
    \k \neq \arr{s} \\
    \G \has e : \vc{\t,\l_e} \\
    \l_e \leq_\l \l_x }
  { \M (x) := e }

  \xinfer{a[e_1] := e_2} % ArrAssign
  { \mu (a) = \vc{\t,\l_x,\k} \\
    \k = \arr{s} \\
    \G \has e_1 : \vc{\uint{max},\public} \\
    \G \has e_2 : \vc{\t,\l_e} \\
    \l_e \leq_\l \l_x }
  { \M (a,e_1) := e_2 }

  \xinfer{\kif (e) \{ s_1 \} \kelse \{ s_2 \}} % If
  { \G \has e : \vc{bool,\l} }
  { }

  \xinfer{\kfor (\vc{\t,\public}i \kfrom e_1 \kto e_2) \{ s \}} % For
  { i \notin \mu \\
    \G \has e_1 : \vc{\t,\public} \\
    \G \has e_2 : \vc{\t,\public} }
  { }

  \xinfer{\kret e} % Ret
  { \G \has e : \vc{\t,\l_e} \\
    \F (f) = fdec : \vc{\t,\l_f} \\
    \l_e \leq_\l \l_f }
  { }

\end{mathpar}
\end{document}
