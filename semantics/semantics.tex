\documentclass[11pt]{article}
\usepackage{amsmath,amssymb}
\usepackage{supertabular}
\usepackage{geometry}
\usepackage{ifthen}
\usepackage{alltt}%hack
\geometry{a4paper,dvips,twoside,left=22.5mm,right=22.5mm,top=20mm,bottom=30mm}
\usepackage{color}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{mathpartir}
\usepackage{mathtools}
\usepackage{etextools}
\usepackage{suffix}
\usepackage{comment}
\usepackage{fancyhdr}

\makeatletter
    \newcommand{\DeclarePairedDelimiterCase}[2]{%
        \newcommand#1[1][]{%
            \ifthenelse{\equal{##1}{normal}}%
            {#2}%
            {%
                \ifthenelse{\equal{##1}{big}\OR\equal{##1}{Big}\OR\equal{##1}{bigg}\OR\equal{##1}{Bigg}}%
                {\expandnext{#2[}{\csname##1\endcsname}]}%
                {#2*}%        % standard case using \left and \right
            }%
        }%
    }
    \newcommand{\DeclarePairedDelimiterY}[4][Temp]{%
        \expandafter\DeclarePairedDelimiter\csname#2#1\endcsname{#3}{#4}%
        \expandnext{\expandnext{\DeclarePairedDelimiterCase}{\csname#2\endcsname}}{\csname#2#1\endcsname}%
    }
    \newcommand{\DeclarePairedDelimiterXY}[6][Temp]{%
        \expandafter\DeclarePairedDelimiterX\csname#2#1\endcsname[#3]{#4}{#5}{#6}%
        \expandnext{\expandnext{\DeclarePairedDelimiterCase}{\csname#2\endcsname}}{\csname#2#1\endcsname}%
    }
\makeatother

\DeclarePairedDelimiterY{floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiterY{ceil}{\lceil}{\rceil}
\DeclarePairedDelimiterY{abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\vc}{\langle}{\rangle}

\newcommand\has\vdash
\newcommand\stmto{\ \Longrightarrow\ }

\newcommand\G\Gamma
\newcommand\F{\mathbb{F}}
\renewcommand\S\Sigma
\renewcommand\b{b}
\renewcommand\t\tau
\renewcommand\k\sigma
\renewcommand\l\ell
\newcommand\m\mu
\newcommand\M{\mathcal{M}}

\newcommand\bool{\textsc{Bool}}
\newcommand\uint[1]{\textsc{UInt}\_{#1}}
\renewcommand\int[1]{\textsc{Int}\_{#1}}
\newcommand\arr[1]{\textsc{Arr}\vc{#1}}
\WithSuffix\newcommand\arr*{\textsc{Arr}}

\newcommand\arrview[1]{\textsc{view}(#1)}

\newcommand\public{\textsc{Public}}
\newcommand\unknown{\textsc{Unknown}}
\newcommand\secret{\textsc{Secret}}

\newcommand\const{\textsc{Const}}
\newcommand\mut{\textsc{Mut}}

\newcommand\ktrue{\textsc{true}}
\newcommand\kfalse{\textsc{false}}

\newcommand\kif{\textsc{if }}
\newcommand\kelse{\textsc{ else }}
\newcommand\kfor{\textsc{for }}
\newcommand\kfrom{\textsc{ from }}
\newcommand\kto{\textsc{ to }}
\newcommand\kret{\textsc{return }}

\newcommand{\ottcom}[1]{\text{#1}}
\newcommand{\grammar}[1]{\begin{supertabular}{lcll}#1\\\end{supertabular}}
\newcommand{\gramrule}[2]{\multicolumn{4}{l}{\textsc{#2}} \\ $#1$ & $::=$ }
\newcommand{\gramitem}[2][]{& $|$ & $#2$ & $\ottcom{#1}$}

\pagestyle{fancy}
\chead{\today}

\begin{document}

\subsubsection*{Grammar}

\begin{mathpar}

  \grammar
  { \gramrule{\b}{Base type} \\
    \gramitem{\bool} \\
    \gramitem{\uint{n}} \\
    \gramitem{\int{n}} }

  \grammar
  { \gramrule{\t}{Type} \\
    \gramitem{\b} \\
    \gramitem{\arr{\b,n}} }

  \grammar
  { \gramrule{\l}{Label} \\
    \gramitem{\public} \\
    %\gramitem{\unknown} \\
    \gramitem{\secret} }

  \grammar
  { \gramrule{\k}{Mutability} \\
    \gramitem{\const} \\
    \gramitem{\mut} }

  \grammar
  { \gramrule{arg}{Function argument} \\
    \gramitem[by value]{e} \\
    \gramitem[by reference]{\mut\ x} }

  \grammar
  { \gramrule{e}{Expression} \\
    \gramitem{\ktrue} \\
    \gramitem{\kfalse} \\
    \gramitem[integer literal]{c} \\
    \gramitem[variable]{x} \\
    \gramitem[array]{a} \\
    \gramitem[array get]{a[e]} \\
    \gramitem[unary op]{\ominus e} \\
    \gramitem[binary op]{e_1 \oplus e_2} \\
    \gramitem[function call]{f(arg_1,\dots,arg_n)} }

  \grammar
  { \gramrule{a}{Array} \\
    \gramitem[array comprehension]{\vc{\t,n}x \Rightarrow e} \\
    \gramitem[array view]{\arrview{a,e,n}} }

  \grammar
  { \gramrule{s}{Statement} \\
    \gramitem[sequence]{s_1 ; s_2} \\
    \gramitem[variable declaration]{\vc{\t,\l,\k} x := e} \\
    \gramitem[variable assignment]{x := e} \\
    \gramitem[array assignment]{a[e_1] = e_2} \\
    \gramitem[conditional]{\kif e\ \{ s_1 \} \kelse \{ s_2 \}} \\
    \gramitem[loop]{\kfor \vc{\b} x \kfrom e_1 \kto e_2\ \{ s \}} \\
    \gramitem[return]{\kret e} }

  \grammar
  { \gramrule{fdec}{Function Definition} \\
    \gramitem{\vc{\b,\l} f ( \vc{\t_1,\l_1,\k_1}x_1 , \dots , \vc{\t_n,\l_n,\k_n}x_n )\ \{ s \}} }

\end{mathpar}

\subsubsection*{Type Lattice}
\begin{mathpar}

  \infer
  { n_1 < n_2 }
  { \uint{n_1} <_\t \uint{n_2} }

  \infer
  { n_1 < n_2 }
  { \int{n_1} <_\t \int{n_2} }

  \infer { }
  { \uint{n} <_\t \int{2n} }

  \infer { }
  { \public <_\l \secret }

  \infer { }
  { \const <_\k \mut }

  \infer
  { \t_1 <_\t \t_2 \\
    \G \has e : \vc{\t_1, \l} }
  { \G \has e : \vc{\t_2, \l} }

  \infer { }
  { \l \cup \l = \l }

  \infer { }
  { \l \cup \secret = \secret }

\end{mathpar}

\subsubsection*{Parameter Passing}
\begin{mathpar}

  \infer
  { \G \has e : \vc{\t,\l_1} \\
    \l_1 \leq_\l \l_2 }
  { \vc{\t,\l_2,\const} \gets e }

  \infer
  { \m (x) = \vc{\t,\l,\mut} }
  { \vc{\t,\l,\mut} \gets \mut\ x }

\end{mathpar}

\subsubsection*{Expressions}
\begin{mathpar}

  \infer[Var]
  { \m (x) = \vc{\t,\l,\k} }
  { \G \has x : \vc{\t,\l} }

  \infer[Unop]
  { \G \has e : \vc{\t_1,\l_1} \\
    \ominus : \vc{\t_1,\l_1} \to \vc{\t_2,\l_2} }
  { \G \has \ominus e : \vc{\t_2,\l_2} }

  \infer[Binop]
  { \G \has e_1 : \vc{\t_1,\l_1} \\
    \G \has e_2 : \vc{\t_2,\l_2} \\
    \oplus : \vc{\t_1,\l_1} \to \vc{\t_2,\l_2} \to \vc{\t_3,\l_3} }
  { \G \has e_1 \oplus e_2 : \vc{\t_3, \l_3 } }

  % Instead of dynamic looping or masking,
  % just fall back to static analysis;
  % if we cannot determine statically that it's ok
  % then the program fails typechecking
  \infer[ArrGet]
  { \m (a) = \vc{\arr{\b,n},\l,\k} \\
    \G \has e : \vc{\uint{max},\public} }
  { \G \has a[e] : \vc{\b,\l} }

  \infer[FnCall]
  { \F (f) = fdec (\vc{\t_1,\l_1,\k_1}x_1, \dots, \vc{\t_n,\l_n,\k_n}x_n) : \vc{\b,\l} \\
    \vc{\t_1,\l_1,\k_1}x_1 \gets arg_1 \\ \cdots \\ \vc{\t_n,\l_n,\k_n}x_n \gets arg_n }
  { \G \has f(arg_1,\dots,arg_n) : \vc{\b,\l} }

  \infer[True] { } { \G \has \ktrue : \vc{\bool,\public} } \\
  \infer[False] { } { \G \has \kfalse : \vc{\bool,\public} }

  \infer[PosNumber]
  { c >= 0 \\
    n = \ceil{\log_2 c} }
  { \G \has c : \vc{\uint{n},\public} }

  \infer[NegNumber]
  { c < 0 \\
    n = \ceil{\log_2 \abs{c}}  + 1 }
  { \G \has c : \vc{\int{n},\public} }

  \infer[ArrComp]
  { \G \has e : \vc{\b,\l} }
  { \G \has \vc{\b,n}x \Rightarrow e : \vc{\arr{\b,n},\l} }

  \infer[ArrView]
  { \m (a) = \vc{\arr{\b,n},\l,\k} \\
    \G \has e : \vc{\uint{max},\public} \\
    n' \leq n }
  { \G \has \arrview{a,e,n'} : \vc{\t,\l} }

\end{mathpar}

\subsubsection*{Statements}
\begin{mathpar}

  \newcommand\stmtitle{}
  \newcommand\stt[1]{\renewcommand\stmtitle{$#1 \stmto$}}
  \newcommand\xinfer[3]{\stt{#1}\infer[\stmtitle]{#2}{#3}}

  \infer[Seq]
  { \S\vc{\l_s} \has s_1 : \l'_s \\
    \S\vc{\l'_s} \has s_2 : \l''_s }
  { \S\vc{\l_s} \has s_1 ; s_2 : \l'_s \cup \l''_s }

  \infer[VarDec]
  { \G \has e : \vc{\t,\l_1} \\
    \l_1 \leq_\l \l_2 }
  { \S\vc{\l_s} \has \vc{\t,\l_2,\k} x := e : \public \\\\
    \mu (x) = \vc{\t,\l_2,\k} \text{\tiny\ (scoping?)} \\\\
    \text{\tiny (how to ensure no \mut\ view of \const\ array?)} }

  \infer[VarAssign]
  { \mu (x) = \vc{\b,\l_1,\mut} \\
    \G \has e : \vc{\b,\l_2} \\
    \l_2 \leq_\l \l_1 }
  { \S\vc{\l_s} \has x := e : \public }

  \infer[ArrAssign]
  { \mu (a) = \vc{\arr{\b,n},\l_1,\mut} \\
    \G \has e_1 : \vc{\uint{max},\public} \\
    \G \has e_2 : \vc{\b,\l_2} \\
    \l_2 \leq_\l \l_1 }
  { \S\vc{\l_s} \has a[e_1] := e_2 : \public }

  \infer[If]
  { \G \has e : \vc{\bool,\l} \\
    \S\vc{\l \cup \l_s} \has s_1 : \l'_s \\
    \S\vc{\l \cup \l_s} \has s_2 : \l''_s }
  { \S\vc{\l_s} \has \kif e\ \{ s_1 \} \kelse \{ s_2 \} : \l'_s \cup \l''_s }

  \infer[For]
  { \G \has e_1 : \vc{\b,\public} \\
    \G \has e_2 : \vc{\b,\public} \\
    \b = \uint{s} \lor \b = \int{s} \\
    \S\vc{\l_s} \has s : \l'_s }
  { \S\vc{\l_s} \has \kfor \vc{\b} x \kfrom e_1 \kto e_2\ \{ s \} : \l'_s \\\\
    \mu (x) = \vc{\b,\public,\const} \text{\tiny\ (scoping?)}}

  \infer[Ret]
  { \G \has e : \vc{\b,\l_1} \\
    \F (f) = fdec : \vc{\b,\l_2} \\
    \l_1 \leq_\l \l_2 }
  { \S\vc{\l_s} \has \kret e : \l_s }

\end{mathpar}
\end{document}
