
secret int32 tls1_cbc_remove_padding_const(secret uint8[length] data, 
                                           public uint32 length,
                                           secret uint32 padding_length,
                                           public uint32 overhead,
                                           ref secret uint32 new_length) {
    //if (length < (overhead)) {
    

    /*
     * The padding consists of a length byte at the end of the record and
     * then that many bytes of padding, all with the same value as the length
     * byte. Thus, with the length byte included, there are i+1 bytes of
     * padding. We can't check just |padding_length+1| bytes because that
     * leaks decrypted information. Therefore we always have to check the
     * maximum amount of padding possible. (Again, the length of the record
     * is public information so we can use it.)
     */
    public uint32 to_check = 256;
    if (to_check > length) { // public
        to_check = length;
    } else {}

    for (uint32 i = 0 to to_check) {
        if (data[length - 1 - i] != padding_length) {
            return -1;
        }
        else {}
    }

    new_length = length - padding_length - 1;
    if (length < (overhead + padding_length)) {
        return -1;
    }
    else {
        return 1;
    }
}
