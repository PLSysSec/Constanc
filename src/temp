open Llvm
open Llvm_executionengine
open Llvm_target
open Typecheck
open Pos
open Ctypes

exception REPL_Error

let fake_pos = { file="JIT"; line=0; lpos=0; rpos=0 }
let count = ref 0

let expr_to_fun e =
  let ret_int = make_ast fake_pos (Ast.Int 32) in
  let pub = make_ast fake_pos Ast.Public in
  let ret_type = make_ast fake_pos (Ast.BaseET(ret_int, pub)) in 
  let name = ("fun_ptr" ^ (string_of_int !count)) in
  let fun_name = make_ast fake_pos name in
  count := !count + 1;
  let body = make_ast fake_pos (Ast.Return e) in
  name, make_ast fake_pos (Ast.FunDec(fun_name, (Some ret_type), [], [body]))

let texpr_to_fun (expr :Tast.expr) (venv : Tast.variable_type Env.env) =
  match expr.data with
    | (expr',ty) ->
      let ret_ty = make_ast fake_pos ty in
      let name = "fun_ptr" ^ (string_of_int !count) in
      let fun_name = make_ast fake_pos name in
      count := !count + 1;
      let body = make_ast fake_pos (Tast.Return expr) in
      let block = (venv, [body]) in
      name, make_ast fake_pos (Tast.FunDec(fun_name, (Some ret_ty), [], block))

(*
type c =
  | Void
  | Int32

let meh = function
  | Void -> Foreign.funptr (void @-> returning void)
  | Int32 -> Foreign.funptr (void @-> returning int32_t)

let get_ctype_of_fun (ret_ty : Tast.expr_type option) : 'a Ctypes.typ =
  let ctype_of_bt (t : Tast.base_type') : 'a Ctypes.typ = match t with
    | Tast.UInt 32 -> uint32_t in
  let ctype_of_et (t : Tast.expr_type') : 'a Ctypes.typ = match t with
    | Tast.BaseET(bt,ml) -> ctype_of_bt (bt.data)
    | Tast.ArrayET(at,ml,mut) -> raise REPL_Error in
  match ret_ty with
    | None -> void
    | Some(ty) -> ctype_of_et (ty.data)
*)
(*
let rec repl ctx mod' builder execution_engine fenv venv cg_fenv =
  print_string "fact>"; flush stdout;
  let lexbuf = Lexing.from_channel stdin in
  let ast = Parser.expr_top Lexer.token lexbuf in
  print_string ((Ast.show_expr ast) ^ "\n");
  let name,ast' = expr_to_fun ast in
  let tast = tc_fdec fenv ast' in
  print_string ((Tast.show_function_dec tast) ^ "\n");
  let f = Codegen.codegen_fun ctx mod' builder cg_fenv tast in
  (* JIT the function, returning a function pointer. *)
  run_static_ctors execution_engine;
  let ty = Foreign.funptr (void @->returning int32_t) in
  let fun_ptr = get_function_address name ty execution_engine in
  print_string "Evaluated to:\n";
  print_string (Int32.to_string (fun_ptr ()));
  (*print_float (GenericValue.as_float Codegen.double_type result);*)
  print_newline ();
  let m = "Fact REPL " ^ (string_of_int !count) in
  let mod'' = create_module ctx m in
  remove_module mod' execution_engine;
  dispose_module mod';
  run_static_dtors execution_engine;
  let execution_engine' = create mod'' in
  repl ctx mod'' builder execution_engine' fenv venv cg_fenv
*)

(*
  Used in the typecheck phase. We need to keep track of variables and functions
  declared in the REPL so they can be called. Scoping gets interesting here since we
  are allowed to declare variables outside of functions. To address this, free variables
  are not allowed in functions.
*)
type type_envs = {
  type_venv: Tast.variable_type Env.env;
  type_fenv: Tast.function_dec Env.env;
}

(*
  Used in the codegen phase. We need to remember declared variables and functions.
*)
type llvm_envs = {
  llvm_venv: Llvm.llvalue Env.env;
  llvm_fenv: Codegen.fenv
}

let create_llvm_mod llcontext jit =
  let m = "Fact REPL " ^ (string_of_int !count) in
  let mod' = create_module llcontext m in
  add_module mod' jit;
  mod'

let execute_tast type_envs ctx mod' builder cg_fenv jit = function
  | Tast.FunctionDec fd -> raise REPL_Error
  | Tast.Statement s -> raise REPL_Error
  | Tast.Expression e ->(*)
    (* We need to transform the expr into a function so it can be JITed *)
    let name,tast_fun = texpr_to_fun e type_envs.type_venv in
    (* Generate LLVM *)
    let llvm = Codegen.codegen_fun ctx mod' builder cg_fenv tast_fun in
    (* JIT the function, returning a function pointer. *)
    run_static_ctors jit;
    let ty = Foreign.funptr (void @->returning int32_t) in
    let fun_ptr = get_function_address name ty jit in
    print_string (Int32.to_string (fun_ptr ()));
    print_newline ()*)raise REPL_Error

let rec repl2 mod' ctx builder jit type_envs ll_envs cg_fenv =
  (* Set the prompt *)
  print_string "fact>"; flush stdout;
  (* Lex and parse some stuff from stdin *)
  let ast = parse () in
  begin
    match ast with
    | None -> print_string "Parse error\n"
    | Some ast ->
      (* We made it to the typecheck phase *)
      let tast = tc_top_level type_envs ast in
      (*execute_tast type_envs ctx mod' builder cg_fenv jit tast;*) ()
  end;
  let mod'' = create_llvm_mod ctx jit in
  repl2 mod'' ctx builder jit type_envs ll_envs cg_fenv

and parse () =
  let print_syntax_error = function
    | Err.TypeError s -> print_string(s ^ "\n")
    | _ -> () in
  let lexbuf = Lexing.from_channel stdin in
  try Some(Parser.top_level Lexer.token lexbuf) with
    | _ -> let p = to_pos ~buf:(Some lexbuf) lexbuf.lex_curr_p lexbuf.lex_curr_p in
           print_syntax_error (Err.errSyntax p); None

and tc_top_level type_envs = function
  | Ast.FunctionDec fd -> raise REPL_Error
  | Ast.Statement s -> raise REPL_Error
    (*let tast' = Typecheck.tc_stm type_envs.type_fenv type_envs.type_venv s in
    Tast.Statement tast'*)
  | Ast.Expression e ->
    let tast = Typecheck.tc_expr type_envs.type_fenv type_envs.type_venv e in
    Tast.Expression tast

let _ =
  ignore(initialize ());
  let ctx = global_context () in
  let mod' = create_module ctx "Initial module" in
  let builder = Llvm.builder ctx in
  let execution_engine = create mod' in
  add_module mod' execution_engine;
  let fenv = Env.new_env () in
  let venv = Env.new_env () in
  let cg_fenv = Codegen.new_fenv () in
  let ll_venv = Env.new_env () in
  let type_envs = { type_fenv=fenv; type_venv=venv } in
  let ll_envs = { llvm_venv=ll_venv; llvm_fenv=cg_fenv } in
  repl2 mod' ctx builder execution_engine type_envs ll_envs cg_fenv
