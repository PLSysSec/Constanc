\section{Language Design}
\label{sec:design}

The \constc system is comprised of two distinct languages: \constc proper, which end-users
will develop programs in, and \ccore, an internal language with specific timing guarantees. Before diving into the languages, we briefly outline our threat model.

\subsection{Threat Model}
For \constc, we assume an adversary has remote access to the machine running the code. The adversary has the ability to measure the amount of time it takes for \constc code to run. We also assume the caller has not been compromised and that they are invoking \constc functions with valid values(as opposed to null values).

\subsection{ConstanC}

The \constc language is the language we intend end-users of our system to program in.
As \constc is intended to replace low-level code, the language is designed to
feel very similar to C, to make it more accessible for developers.

There are, however, some necessary restrictions on what can be expressed in \constc.
For example, recursion of any sort is disallowed. Loop constructs are restricted to
for-loops where loop bounds can only be constants. While these would be onerous restrictions for a general
programming language, \constc is intended for a very specific domain where these
features of a language are generally unnecessary.

The language supports 32-bit signed integers, boolean values, and arrays of bytes.
Most arithmetic and bitwise operations on these values are supported.

We do not prove timing guarantees directly in \constc; instead, we show
that the \ccore language has the security guarantees we require, and transform all programs
in \constc to functionally equivalent programs in \ccore.

The full grammar of \constc can be found in \Cref{sec:constcgrammar}.

\begin{figure*}[t]
\begin{druleparx}[Stt]
\drule{Stt-var-assign}
\drule{Stt-if}
\drule{Stt-ret}
\end{druleparx}
%\drulesx[Stt]{var-assign,if,ret}
        \caption{Excerpt of semantic transformations from \constc to \ccore. Full rule set can be found in \Cref{sec:coretransform}.}
    \label{fig:transform}
\end{figure*}

\subsection{ConstCore}

The \ccore language is a \textsc{While}-like language \cite{ref:while} with highly limited
control flow. Notably, there are no conditional branching instructions, and the
only loop construct is a for loop with static loop bounds. The type system
is also more restrictive than that of \constc: we support only 32-bit
signed integers and \bytearrays.

Comparison operators in \ccore evaluate integer-width bitmasks of either all
high bits (if the comparison is true) or all low bits (if false). The resulting
bitmasks are then typically used to mask expressions that depend on the conditional
result. For example, if a variable \texttt{x} was to be incremented by \texttt{3}
only if the variable \texttt{y} was greater than \texttt{5}, we could express that
as the following statement:
\begin{center} \texttt{x := x + ((y > 5) \band 3)} \end{center}
The result of the expression \texttt{y > 5} will either be \texttt{0b1111...} if true
or \texttt{0b0000...} if false. The \band operator performs a bitwise masking operation,
either leaving the value \texttt{3} as-is (if the bitmask was all \texttt{1}s) or zeroing
it out (if the bitmask was all \texttt{0}s). Thus \texttt{x} gets incremented only
if the condition holds.

To show the constant-time nature of \ccore, we adopt the
\emph{program-transcript security model} from Molnar et al. \cite{molnar2005},
keeping a log of executed instructions as part of our small-step
semantics (see \autoref{sec:ottsemantics}). We then show that every function in
\ccore has the following property: For every function $f$, there exists a
transcript $f_\kappa$ such that for any input $x_1,\dots,x_n$ to $f$ and
current transcript $\kappa$, the transcript $\kappa'$, when $f$ returns, is
exactly $\kappa + f_\kappa$. That is to say, the program path through any
function in \ccore does not depend on the inputs to the function.

However, even if a function always follows the same program transcript,
it might still take varying amounts of real-world time, depending
on how the physical CPU implements its instructions \todo{cite}. Our compiler
currently targets LLVM IR, but with Intel x86 assembly in mind; it is currently unknown \todo{fact
check} which instructions in this architecture are truly constant time. However, certain
instructions, such as integer division (\texttt{idiv}), are known to have timing variations
based on the input values \todo{cite}. Our
mitigation strategy is to restrict ourselves to instructions that, to the best of our knowledge,
run in constant time with respect to arguments.
These include basic arithmetic (excluding division and modulo) and comparison operators, as well as
simple loads, stores, and calls. The constant-time nature of compiled
\ccore is thus reduced to the timing properties of the set of chosen instructions.

\subsection{Transformations}

If we can transform any program in \constc to an equivalent program in \ccore, then
we can compile any \constc program to a program with the timing guarantees shown in \ccore.

Since both \ccore
and \constc are side effect-free languages, we simply need to show that for
every function $f$ in \constc, the corresponding transformed function
$f_{\textnormal{core}}$ returns an equivalent value given equivalent arguments.

We ensure this equivalence by keeping a ``context'', which is a bitmask
representing the control flow the of the function at the current statement.
This bitmask is either \emph{high} (all 1s) or \emph{low} (all 0s).
Any variable assignment
%~\texttt{x := v}~
in \constc is transformed
%to the following statement in \ccore:
%\begin{center}
%  \texttt{x := ((ctx\bandx rnset)\bandx v)\borx(\bnot (ctx\bandx rnset)\bandx x)}
%\end{center}
%The formal transformation is given in \rref{Stt-var-assign}.
via the semantic transformation \rref{Stt-var-assign} shown in \autoref{fig:transform},
where \texttt{ctx} is the context bitmask and ~\band, \bor, \bnot\ represent
bitwise \emph{and}, \emph{or}, and \emph{not} operations respectively.
The \texttt{rnset}
variable is an additional bitmask used for tracking early function return and
is described below.  With this transformation, variables are only updated to
new values if the context at the time of execution indicates that the original
program control flow would have made it to that statement.

Conditional branches are transformed by executing the statements in both
branches. However, before each block is executed, the context bitmask is
updated with the branch condition. Thus the statement
%~\texttt{if bexpr then s1 else s2}~
is transformed via the \rref{Stt-if} in \autoref{fig:transform},
%is transformed to:
%\begin{center}
%  \pbox{\textwidth}{
%    \texttt{b := bexpr} \\
%    \texttt{oldctx := ctx} \\
%    \texttt{ctx := oldctx \band b} \\
%    \texttt{\textlangle{}s1\textrangle} \\
%    \texttt{ctx := oldctx \band (\bnot b)} \\
%    \texttt{\textlangle{}s2\textrangle} \\
%    \texttt{ctx := oldctx}
%  }
%\end{center}
where \texttt{\textlangle{}s1\textrangle} and \texttt{\textlangle{}s2\textrangle} are the transformations of \texttt{s1} and \texttt{s2}, and \texttt{b} is a fresh temporary variable for each instance of a branching
statement. This ensures that nested conditionals still function as expected.
%The formal transformation is given in \rref{Stt-if}.

Return statements in \constc are dealt with by constructing two additional
variables for every function: $rval$ (initialized low) and $rnset$ (initialized
high). A return statement in \constc is translated to an assignment to $rval$,
gated by the context as above. Additionally, $rnset$ (``return value not
set'') is updated to reflect the current return status.
%as follows:
%\begin{center}
%  \texttt{rnset := rnset \band (\bnot ctx)}
%\end{center}
In this way, $rnset$ remains high until a ``return statement'' is executed
under an active control flow path, at which point it is set low and remains low
for the rest of the function. Since all variable assignments are gated with
$rnset$ in addition to the context, no further variable assignments will cause
updates. The formal transformation can be seen in the \rref{Stt-ret} in \autoref{fig:transform}.
